# 컴포넌트

> 컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위
> 자바 : jar파일
> 루비 : gem 파일
> 닷넷 : DLL
> 컴파일형 언어 : 바이너리 파일의 결합체
> 인터프리터형 언어 : 소스 파일의 결합체

- 여러 컴포넌트를 서로 링크해 실행 가능한 단일 파일로 생성할 수 있다.
- 여러 컴포넌트를 묶어서 .war 파일과 같은 단일 아카이브로 만들 수 있다.
- 컴포넌트 각각을 .jar, .dll 등으로 동적으로 로드할 수 있는 플러그인, .exe 파일로 만들어 독립적으로 배포할 수 있다.

## 컴포넌트의 간략한 역사

> 프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정해야 했으며, 재배치가 불가능했다.
> 라이브러리 함수의 소스코드를 애플리케이션 코드에 직접 포함시켜 컴파일 했으며, 이 라이브러리는 바이너리가 아닌 소스 코드 형태로 유지됐다. 이 방식은 메모리가 부족해서 여러 차례 느리게 읽어야 하는 번거로움이 있었다.

- 컴파일 시간 단축을 위해 프로그래머는 함수 라이브러리 소스 코드를 애플리케이션 코드로부터 분리했고, 개별적으로 컴파일해 특정 위치에 로드했다. 그리고 애플리케이션을 실행해야 할 때 바이너리 함수 라이브러리를 로드하고 애플리케이션을 로드했다.

⇒ 애플리케이션이 커지면서 두 개의 주소 세그먼트로 분리하고, 추가 공간을 할당하는 등의 일을 했다.

## 재배치성

- 재배치가 가능한 바이너리가 해결책이다.
  - 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정
  - 로더는 재배치 코드가 자리할 위치 정보를 전달받았다.
  - 재배치 코드에는 데이터에 어느 부분을 수정해야 정해진 주소에 로드할 수 있는지 알려주는 플래그(메모리의 시작 주소) 삽입

1. 함수 라이브러리를 로드할 위치, 애플리케이션을 로드할 위치를 로더에 지시
2. 로더는 여러개의 바이너리를 입력받아 단순히 하나씩 메모리로 로드하면서 재배치

⇒ 필요한 함수만 로드 가능

- 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정
- 프로그램이 라이브러리 함수를 호출하면 컴파일러는 라이브러리 함수 이름을 외부 참조로 생성
- 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성

> 외부 정의를 로드할 위치가 정해지면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.
> 이렇게 링킹 로더가 탄생했다.

## 링커

> 링킹 로더의 등장으로 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.
> 하지만 프로그램이 커지면서 링킹 로더가 너무 느려 사용할 수 없었다.

함수 라이브러리는 magnetic tape 등의 느린 장치에 저장되었으며 디스크도 상당히 느렸다.

링킹 로더는 이런 느린 장치를 사용해 수십, 수백 개의 바이너리 라이브러리를 읽고 외부 참조를 해석해야 했다.

⇒ 로드와 링크를 두 단계로 분리

- 링크
  - 링커라는 별도의 애플리케이션으로 이 작업을 분리
  - 링커는 링크가 완료된 재배치 코드를 만들어주었고, 로더의 속도를 빠르게 해줬다.
  - 링커는 느리게 실행 파일을 만들지만, 한번 만든 실행 파일은 빠르게 로드할 수 있었다.
  - 로드 시간은 빨라졌지만 컴파일-링크 구간의 병목이 문제가 되었다.
- Moore의 법칙
  - 디스크는 작아지고 빨라졌다.
  - 메모리는 저렴해졌고, 디스크에 저장된 많은 데이터를 모두 RAM에 캐싱할 수 있게 되었다.
  - 컴퓨터 크록 속도는 1MHz에서 100MHz까지 증가했다.
  - 링크 시간은 초 단위로 작아졌다.
- 액티브 X, 공유 라이브러리, .jar
  - 컴퓨터와 장치가 빨라져 로드와 링크를 동시에 할 수 있게 됐다.
  - 다수의 .jar 파일, 공유 라이브러리를 순식간에 서로 링크한 후 실행
  - 컴포넌트 플러그인 아키텍처

## 결론

소프트웨어 컴포넌트 = 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일
