# DIP: 의존성 역전 원칙

> 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 의존하면 안된다. 대신 세부사항이 정책에 의존해야 한다.

- 유연성이 극대화된 시스템
  - 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는다.
- 정적 타입 언어
  - use, import, include : 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조. 구체적인 대상에 의존하지 않는다.
- 동적 타입 언어
  - 소스 코드 의존 관계에서 구체 모듈을 참조하면 안된다.
  - 구체 모듈 ? 호출할 함수가 구현된 모듈이면 ?
- 구체 클래스
  - 의존성을 벗어날 수 없는 클래스가 있는데
  - 이 클래스는 매우 안정적이며 변경될 일이 없고, 있더라도 엄격하게 통제된다.
  - 이렇듯 운영체제나 플랫폼 같이 안정성이 보장된 환경은 예외
  - 우리가 생각할 것은 바로 변동성이 큰 구체적인 요소다. (개발 중인, 자주 변경될 수 밖에 없는 모듈들)

### 안정된 추상화

- 추상 인터페이스에 변경이 생기면 구체화한 구현체도 수정해야 한다.
- 구현체가 변해도 인터페이스는 변경될 필요가 없으므로 변동성이 낮다.
- 이 변동성을 낮추는 것이 소프트웨어 설계의 기본

> 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일을 지양하고 안정된 추상 인터페이스를 선호하는 아키텍처

**구체적인 코딩 실천법**

1. 변동성이 큰 구체 클래스를 참조하지 말라
   1. 대신 추상 인터페이스를 참조
   2. 이 규칙은 언어가 정적 타입이든 동적 타입이든 관계 없이 모두 적용된다.
   3. 이 규칙은 객체 생성 방식을 강하게 제약하고
   4. 일반적으로 추상 팩토리를 사용하도록 강제한다.
2. 변동성이 큰 구체 클래스로부터 파생하지 말라
   1. 정적 타입 언어에서 상속은 변경이 어렵다.
   2. 때문에 신중하게 사용해야 한다.
3. 구체 함수를 오버라이드 하지 말라
   1. 구체 함수는 소스 코드 의존성을 필요로 한다.
   2. 구체 함수를 오버라이드하면 이 의존성을 제거할 수 없고, 상속하게 된다.
   3. 차라리 추상 함수로 선언하고 각자의 용도에 맞게 구현하라
4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
   1. 이게 DIP 원칙

### 팩토리

변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.

해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생한다.

⇒ 의존성을 관리하기 위해 추상 팩토리(Abstract Factory) 패턴을 사용

소스 코드 의존성은 모두 한 방향, 추상적인 쪽으로 향한다.

- 추상 컴포넌트
  - 애플리케이션의 모든 고수준 업무 규칙을 포함
- 구체 컴포넌트
  - 업무 규칙을 다루는 필요한 모든 세부사항 포함
- 제어 흐름
  - 소스 코드 의존성과 정 반대 방향으로 역전

### 구체 컴포넌트

구체 컴포넌트에 구체적인 의존성이 하나있고, DIP를 위배한다. 이는 일반적인 일

DIP 위배 클래스를 적은 수의 구체 컴포넌트 내부로 모아 시스템의 나머지 부분과 분리할 수 있다.

// 이렇게 분리된 구체 컴포넌트를 메인(Main)이라고 부른다. (main 함수)

### 결론

추상 컴포넌트와 구체 컴포넌트를 나누는 곡선을 경계로 의존성은 더 추상적인 엔티티가 있는 쪽으로 향한다.

이 규칙을 의존성 규칙이라 부를 것이다.
