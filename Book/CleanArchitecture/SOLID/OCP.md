# OCP: 개방-폐쇄 원칙

> 기존 코드를 수정하기보다 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있어야 소프트웨어 시스템을 쉽게 변경할 수 있다.

- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
  - 소프트웨어 개체의 행위는 확장할 수 있어야 하지만 이때 개체를 변경하면 안된다.
  - OCP는 클래스, 모듈을 설계할 때 도움되는 원칙이라고 알고 있지만
    - 아키텍처 컴포넌트 수준에서 고려할 때 훨씬 중요하다.

### 사고 실험

- SRP : 서로 다른 목적으로 변경되는 요소를 적절하게 분리
- DIP : 의존성을 체계화
- 책임의 분리 ⇒ 책임 중 하나에서 변경이 발생하더라도 다른 게 변경되지 않도록 소스 코드 의존성 조직화
  - 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장
  - 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- 처리 과정을 클래스 단위로 분할하고, 클래스를 컴포넌트 단위로 구분해야 한다.
  - 컴포넌트 : Controller + Interactor + Database + Presenter + View
  - 이 모든 관계는 단 방향으로 이뤄진다. 보호를 위해 한 쪽이 한 쪽을 의존
  - 업무 규칙을 포함하는 컴포넌트는 특별한 위치에서 OCP를 잘 준수하고 있어야 한다. 어떤 변경도 영향을 주지 않는다.

### 방향성 제어

- 컴포넌트 간 의존성이 제대로 된 방향으로 향하는 것이 중요하다.
- 인터페이스를 적절히 위치시켜 의존성을 역전시켜야 한다.

### 정보 은닉

- 방향성 제어와 다르게, 추이 종속성을 막기 위한 인터페이스도 필요하다.
  - 추이 종속성을 가지게 되면
    - 소프트웨어 엔티티는 ‘자신이 직접 사용하지 않는 요소에 의존하면 안 된다’는 소프트웨어 원칙을 위반한다. (ISP, CRP)
    - 추이 종속성 : 클래스 A가 클래스 B에 의존하고 클래스 B가 클래스 C에 의존하면 클래스 A는 클래스 C에 의존하게 된다. 클래스 의존성이 순환적이라면 모든 클래스가 서로 의존하게 되는 문제가 있다.
- 저수준 컴포넌트 변경으로부터 고수준 컴포넌트를 보호하는 일의 우선순위가 높지만
  - 고수준 컴포넌트의 변경으로부터 저수준 컴포넌트도 보호되길 바란다.
  - 이를 위해 저수준 컴포넌트의 내부를 은닉한다.

### 결론

목표는 시스템을 확장하기 쉬운 동시에 변경으로부터 시스템이 너무 많은 영향을 받이 않도록 하는 데 있다.

- 시스템을 컴포넌트 단위로 분리하고
- 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.
