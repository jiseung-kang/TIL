# LSP: 리스코프 치환 원칙

> 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들려면 이들이 서로 치환 가능해야 한다.

- S타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있다.
  - T타입을 이용해 정의한 모든 프로그램 P에서
  - o2 자리에 o1을 치환해도 P의 행위가 변하지 않는다면
  - S는 T의 하위 타입이다.

### 상속을 사용하도록 가이드하기

LSP를 준수하면 애플리케이션의 행위가 슈퍼타입의 하위 타입 중 무엇을 사용하는지에 의존하지 않는다.

이들 하위 타입이 모두 슈퍼 타입을 치환할 수 있다.

### 정사각형/직사각형 문제

LSP를 위반하는 전형적인 문제

- 사각형은 직사각형의 하위 타입으로 적합하지 않다.
  - 사각형이 직사각형을 치환할 수 없다.
  - 이런 형태의 LSP 위반을 막기위해 직사각형이 실제로는 사각형인지 검사하는 메커니즘을 추가하는 것
    - 그 행위가 결국 사용하는 타입에 의존하므로 타입을 서로 치환할 수 없게 된다.

### LSP와 아키텍처

- LSP는 상속을 사용하도록 가이드 하는 방법이었다.
  - 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모
  - 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리 상호 치환 가능성에 기대는 사용자들이 존재

### LSP 위배 사례

- 동일한 REST 인터페이스를 반드시 준수하도록 했을 때
  - 준수하지 않을 경우 예외 사항을 처리해야만 한다.
  - 아키텍처는 이 같은 버그로부터 시스템을 격리해야 한다.
  - 모듈을 따로 만들어야 할 수 있다.
  - 아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 한다.

### 결론

- LSP는 아키텍처 수준까지 확장해야 한다.
- 치환 가능성을 위배하면 시스템 아키텍처가 오염되어 상당한 별도 매커니즘을 추가해야 할 수도 있다.
