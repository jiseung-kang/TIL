# 프로그래밍 패러다임

> 소프트웨어 아키텍처는 코드로 시작한다.
> 패러다임을 프로그래밍을 하는 방법으로, 대체로 언어에 독립적이다.
> 패러다임은 어떤 프로그래밍 구조를 사용할지, 언제 이 구조를 사용해야 하는지를 결정한다.

## 패러다임 개요

### 구조적 프로그래밍

최초로 **적용**된 패러다임

무분별한 점프(goto)가 구조에 해로움을 제시하고 if/then/else, do/while/until 등의 구조로 대체했다.

⇒ 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

### 객체 지향 프로그래밍

함수 호출 스택 프레임을 힙으로 옮기면 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수를 오랫동안 유지할 수 있다. 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.

함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장했다.

⇒ 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍

람다 계산법의 기초가 되는 개념은 **불변성**으로, 심볼의 값이 변경되지 않는다는 개념이다.

함수형 언어에는 할당문이 전혀 없다는 뜻으로, 대다수의 함수형 언어는 변수 값을 변경하는 방법이 굉장히 까다롭다.

⇒ 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

### 생각할 거리

각 패러다임은 프로그래머에게서 권한을 박탈하며, 추가적인 규칙(하지 말아야 할 것)을 알려준다.

이들 패러다임 이상으로 제한할 것은 없었으며, 앞으로도 없을 것이다.

### 결론

아키텍처의 경계를 넘나드는 메커니즘으로 다형성을 이용한다.

함수형 프로그래밍으로 데이터 위치와 접근 방식에 규칙을 부과하며,

모듈 기반 알고리즘으로 구조적 프로그래밍을 사용한다.

## 구조적 프로그래밍

### 증명

수학적 원리로 프로그래밍을 인간이 할 수 있게 만들자.

수학자가 유클리드 계층구조를 사용하는 방식을 프로그래머도 사용하자.

입증된 구조를 이용하고, 코드와 결합시키면, 코드는 올바르다.

goto : 모듈을 재귀적으로 분해하는데 방해가된다. 그러면 분할 정복 접근법을 사용할 수 없다.

⇒ 분기와 반복이라는 단순한 제어 구조를 순차 실행과 결합하자.

> 프로그램 제어 구조의 최소 집합 : 순차, 분기, 반복

순차 : 열거법으로 올바름을 입증

분기 : 열거법의 재적용해 올바름을 입증

반복 : 귀납법을 사용하고, 열거법에 따라 올바름을 증명

### 해로운 성명서

Go To Statement Considered Harmful

데이크스트라가 승리했다.

제어흐름을 제약 없이 직접 전환하는 선택권을 언어에서 제공하지 않는다.

### 기능적 분해

구조적 프로그래밍으로 모듈을 재귀적으로 분해할 수 있게 되었다.

이를 토대로 구조적 분석, 구조적 설계가 인기를 끌었다.

이 기법을 사용하면 대규모 시스템을 모듈과 컴포넌트로 나누고, 이들은 입증할 수 있는 더 작은 기능들로 세분화할 수 있다.

### 엄밀한 증명은 없었다

과학적 방법은 반증은 가능하지만 증명이 불가능하다.

### 테스트

테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.

아무리 수학적인 구조를 다루어도 소프트웨어 개발은 수학적인 시도가 아니다.

소프트웨어는 과학과 같다.

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요하며, 테스트로 증명하려고 시도한다.

### 결론

구조적 프로그래밍은 반증 가능한 단위를 만들 수 있다는 점에서 가치있다.

아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여긴다.

## 객체 지향 프로그래밍

OO 설계 원칙

- 데이터와 함수의 조합
  - o.f() ≠ f(o) 인가?
- 실제 세계를 모델링하는 새로운 방법
  - OO가 그래서 뭔데?
- 캡슐화, 상속, 다형성
  - 모든 OO 언어는 이 세가지를 적절하게 조합했거나, 지원해야 한다.

### 캡슐화

데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법

- C : 헤더와 구현체를 분리 (완벽한 캡슐화)
- C++ : 헤더 파일에 멤버 변수 선언. 캡슐화가 깨졋다.
- 자바, C# : 더이상 헤더와 구현체를 구분할 수 없다.

⇒ 많은 언어가 캡슐화를 강제하지 않는다.

⇒ OO 프로그래밍은 프로그래머가 올바르게 행동해서 캡슐화된 데이터를 우회해서 사용하지 않을 것이라는 믿음을 기반으로 한다. (public, private 등의 키워드를 제공해 캡슐화가 optional 해짐)

### 상속

OO 언어가 더 나은 캡슐화는 제공하지 못했지만, 더 나은 상속을 제공했다.

상속 : 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일

OO 언어에서는 upcasting이 암묵적으로 이뤄진다.

### 다형성

OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 편리하게 사용 할 수 있게 해준다.

인터페이스(도메인) → 미들웨어(인프라)

⇒ OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다.

> 플러그인 아키텍처 : 입출력 장치 독립성을 지원하기 위해 만들어졌고, 거의 모든 운영체제에서 구현되었다.

- 의존성 역전
  - 제어흐름은 시스템 행위에 따라 결정되며
  - 소스 코드의 의존성 방향은 반드시 제어흐름을 따르게 된다.
  - 여기에 다형성이 더해지면 의존성 역전이 가능해진다.
  - 인터페이스를 사용하면 고수준 → 저수준 의존이 저수준 → 고수준으로 역전된다.

⇒ UI와 Database가 서로가 아닌 Business Rules에 의존하게 만들 수 있다. 즉 UI와 DB가 업무 규칙의 플러그인. 이들은 배포 독립성, 개발 독립성을 가질 수 있다.

> OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 즉, 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로, 고수준의 정책을 포함하는 모듈과 독립적으로 개발하고 배포할 수 있다.

## 함수형 프로그래밍

### 정수를 제곱하기

함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처

경합 조건, 교착 상태 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다.

불변성은 실현 가능하겠지만 타협이 필요하다.

### 가변성의 분리

가장 주요한 타협은 가변 컴포넌트와 불변 컴포넌트의 분리이다.

불변 컴포넌트에서는 순수하게 함수형으로만 작업이 처리되며, 가변 변수가 허용되지 않는다. 불변 컴포넌트는 변수 상태를 변경할 수 있는 하나 이상의 다른 컴포넌트와 통신한다.

상태 변경은 동시성 문제에 노출되므로 트랜잭션 메모리와 같은 실천법으로 가변 변수를 보호해야 한다.

> 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 하며, 가변 변수를 보호하는 적절한 수단이 있어야 한다.

### 이벤트 소싱

> 애플리케이션의 수명주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력으로 트랜잭션들을 관리할 수 있다.

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 완전한 함수형으로 만들 수 있다.

### 결론

- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율
- 함수형 프로그래밍은 변수 할당에 부과되는 규율

> 소프트트웨어의 구성은 순차, 분기, 반복
