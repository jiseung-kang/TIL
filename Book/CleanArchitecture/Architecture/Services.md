# ‘크고 작은 모든’ 서비스들

서비스 지향 아키텍처와 마이크로서비스 아키텍처

- 서비스를 사용하면 상호 결합이 철저하게 분리되는 것’처럼’ 보인다.
- 서비스를 사용하면 개발과 배포 독립성을 지원하는 것’처럼’ 보인다.

## 서비스 아키텍처

시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.

서비스는 그 자체로 아키텍처를 정의하지 않는다.

모노리틱 시스템이나 컴포넌트 기반 시스템에서 아키텍처를 정의하는 요소는 바로 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다.

서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.

## 서비스의 이점

- 결합 분리의 오류
  - 서비스 사이의 결합이 분리된다.
  - 서로 다른 프로세스, 프로세서에서 실행된다.
  - 서비스는 개별 변수 수준에서는 각각 결합이 분리되지만, 프로세서 내/네트워크 상의 공유 자원 때문에 결합될 가능성이 존재한다.
  - 인터페이스가 잘 정의되어 있어야 하는데 이런건 환상에 불과
- 개발 및 배포 독립성의 오류
  - 데브옵스의 일환으로 전담팀이 각 서비스를 작성하고 유지보수하고 운영하는 책임
  - 확장 가능성
  - 그렇지만 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.
  - 결합 분리의 오류에 따르면 서비스라고 항상 독립적으로 개발/배포/운영할 수 있는 것이 아니다. 데이터나 행위에서 어느정도 결합되어 있다면 결합된 정도에 맞게 개발/배포/운영을 조정해야 한다.

## 야옹이 문제

- 확장 가능한 시스템 구축을 위해 수많은 작은 마이크로 서비스를 기반으로 구축
  - 새로운 기능 구현을 위해 어디를 변경해야 할까?
  - 서비스들은 모두 결합되어 있어서 독립적으로 개발하고 배포하거나 유지할 수 없다.
- 횡단 관심사의 문제
  - 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이런 문제에 직면한다.
    - 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약하다.

## 객체가 구출하다

- 컴포넌트 기반 아키텍처
  - SOLID 설계 : 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함
    - 의존성 규칙도 준수한다.
    - 기존 컴포넌트 추상 기반 클래스를 템플릿 메서드, 전략 패턴 등으로 오버라이드 한다.

## 컴포넌트 기반 서비스

> 서비스에서도 이렇게 할 수 있을까?

- 서비스가 반드시 소규모 단일체(monolith)여야 할 이유는 없다.
- 서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다.
  - 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다.
  - 새로운 기능을 추가하는 행위가 개방 폐쇄 원칙을 준수한다.

## 횡단 관심사

> 아키텍처 경계가 서비스 사이에 있지 않다.

오히려 서비스를 관통하고 서비스를 컴포넌트 단위로 분할한다.

서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.

아키텍처 경계를 정의하는 것은 서비스 내에 위치하는 컴포넌트다.

## 결론

서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로 아키텍처적으로 중요한 요소는 아니다.

시스템의 아키텍처를 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.

시스템의 구성 요소가 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍처가 정의되지 않는다.

서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있으며, 여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다.

클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을 때도 있다.
