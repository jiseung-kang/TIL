# 독립성

좋은 아키텍처는 다음을 지원해야 한다.

### 1. 유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야 한다.

아키텍트의 최우선 관심사는 유스케이스

- 행위를 명확히 하고
- 외부로 드러내며
- 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 하자

행위는 일급 요소로 시스템의 최상위 수준에서 알아볼 수 있다.

### 2. 운영

운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야 한다.

시스템이 단일체로 작성되어 모노리틱 구조를 갖는다면 다중 프로세스, 다중 스레드, 마이크로서비스 형태가 필요해질 때 개선이 어렵다.

아키텍처에서 각 컴포넌트를 적절히 격리해 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것

### 3. 개발

아키텍처는 개발환경 지원에 핵심적인 역할

> 콘웨이의 법칙 : 시스템을 설계하는 조직이라면 어디든 그 조직의 의사소통 구조화 동일한 구조의 설계를 만들어 낼 것

잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

그래야 이 컴포넌트를 독립적으로 작업할 팀에 할당할 수 있다.

### 4. 배포

아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다.

목표 : 즉각적인 배포

좋은 아키텍처는 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.

이러한 아키텍처는 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

- 마스터 컴포넌트
  - 시스템 전체를 하나로 묶고
  - 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.

### 선택사항 열어놓기

선택사항을 가능한 한 많이, 가능한 한 오래 열어두자

### 계층 결합 분리

아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만 유스케이스 전부를 알지는 못한다.

아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용해 의도의 맥락에 따라 다른 이유로 변경되는 것들은 분리하고 동일한 이유로 변경되는 것들은 묶는다.

- 유스케이스에서 UI부분과 업무 규칙 부분을 독립적으로 분리한다.
- 데이터베이스, 쿼리 언어, 스키마 등의 기술적 세부사항을 업무 규칙이나 UI와 분리한다.

이런 식으로 시스템을 결합되지 않은 수평적인 계층으로 분리한다.

- UI
- 애플리케이션에 특화된 업무 규칙
- 애플리케이션에 독립적인 업무 규칙
- 데이터 베이스 등

### 유스케이스 결합 분리

유스케이스는 시스템을 분할하는 자연스러운 방법

각 유스케이스는 UI일부, 애플리케이션 특화 업무 규칙 일부, 애플리케이션 독립적 업무 규칙 일부, 데이터베이스 기능 일부를 사용한다.

⇒ 시스템을 수평적으로 분할하며 얇은 수직적 유스케이스로 분할하자

- 유스케이스의 UI 결합을 분리
- 다른 이유로 변경되는 요소 결합 분리
- 각 유스케이스가 UI와 데이터베이스의 서로 다른 관점을 사용하게

### 결합 분리 모드

- 유스케이스에서 서로 다른 관점이 분리되었다면
  - 높은 처리량과 낮은 처리량 유스케이스가 분리되었을 것
- UI와 데이터베이스가 업무 규칙과 분리되었다면
  - 업무 규칙과 다른 서버에서 실행될 수 있다.

결합 분리는 운영에 도움이 된다.

- 마이크로 서비스
  - 분리된 컴포넌트를 서로 다른 서버에서 실행해야 한다면
  - 이들 컴포넌트가 단일 프로세서의 동일한 주소 공간에 상주하지 않게
  - 분리된 컴포넌트는 반드시 독립된 서비스
  - 일종의 네트워크를 통해 서로 통신해야 한다.

### 개발 독립성

유스케이스의 결합이 분리되면 시스템의 아키텍처는 그 팀의 구조를 뒷받침하게 된다.

### 배포 독립성

유스케이스와 계층 결합이 분리되면 배포 측면에서 유연성이 생긴다.

운영 중인 시스템에서 계층과 유스케이스를 교체할 수 있다.

### 중복

중복 vs 우발적 중복

우발적 중복이 될 코드를 통합하지 않도록 유의하자.

유스케이스를 수직으로 분리할 때 이러한 문제에 부딪힌다.

데이터베이스 쿼리와 스키마를 비슷하게 가진다고 해서 중복을 제거해버리면 안된다.

**중복이 진짜 중복인지 확인하라**

계층을 수평적으로 분리할 때도 레코드의 데이터 구조가 중복되는 것처럼 보일 수 있지만,

뷰 모델을 별도로 만드는 게 그렇게 큰 일이 아니다.

### 결합 분리 모드(again)

- 소스 코드 수준 분리 모드
  - 소스 코드 모듈 사이의 의존성 제거.
  - 하나의 모듈 컴파일이 다른 모듈 변경과 재컴파일을 발생시키지 않는다.
  - 모든 컴포넌트가 같은 주소 공간에서 실행되며, 서로 통신할 때는 간단한 함수 호출만 사용.
  - 컴퓨터 메모리에는 하나의 실행파일 만이 로드된다.
  - 모노리틱 구조
- 배포 수준 분리 모드
  - 배포 가능한 단위(jar, DLL, …)들 사이에서 의존성 제어
  - 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다.
  - 같은 주소 공간에 상주, 단순한 함수 호출로 통신
  - 동일한 프로세서의 다른 프로세스에 상주
  - 프로세스 간 통신, 소켓, 공유 메모리로 통신
  - 독립적으로 배포할 수 있는 단위로 분할
- 서비스 수준 분리 모드
  - 의존하는 수준을 데이터 구조 단위까지 낮춰 순전히 네트워크 패킷으로만 통신
  - 모든 실행 가능한 단위는 소스, 바이너리 변경에 대해 완전히 독립적
  - 서비스, 마이크로 서비스

무엇을 쓸까?

- 초기 단계에는 알기 어렵다. 낮은 수준을 기본 정책으로
  - 비용이 많이 들고 경합이 큰 단위에서 분리된다는 문제가 있다.
  - 개발 시간, 시스템 자원의 비용
- 소스 코드 수준
  - 점차적으로 낮은 수준으로 변경시켜 나가면 된다.

좋은 아키텍처

- 모노리틱, 단일 파일 배포를 하더라도
  - 이후에 독립적으로 배포 가능한 단위들의 집합으로 성장
  - 독립적인 서비스, 마이크로서비스 수준까지 성장
  - 원래대로 돌릴 수도 있어야
  - 결합 분리 모드를 선택사항으로 두어 언제든지 적합한 모드를 선택할 수 있도록

### 결론

변경을 예측해 무리 없이 반영할 수 있어야 한다.
