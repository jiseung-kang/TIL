# 부분적 경계

아키텍처 경계를 완벽하게 만드는 데 많은 비용이 든다.

모든 의존성을 관리해야 한다.

YAGNI(You Aren’t Going to Need It) 원칙 위배

### 마지막 단계를 건너뛰기

독립적으로 컴파일하고 배포할 수 있는 컴포넌트들을 만들고 모아만 두는 것

단일 컴포넌트로 컴파일해서 배포한다. 이들을 관리하는 작업은 하지 않는다.

의존성의 방향 문제, 다시 분리하는 일이 힘들다.

### 일차원 경계

양방향으로 격리된 상태를 유지하기 힘들다.

- Strategy 패턴
  - 쌍방향 인터페이스 필수
  - 위험

### 퍼사드

- 퍼사드 패턴
  - 의존성 역전의 희생
  - 추이 종속성 문제

### 결론

각각 나름의 비용과 장점이 있다. 해당 경계가 실제로 구체화되지 않으면 가치가 떨어진다.

경계를 완벽하게 구현할지 부분적으로 구현할지 결정해야 한다.

## 계층과 경계

수많은 컴포넌트를 어떻게 관리할까

- 소스 코드 의존성을 적절히 관리하고
- 의존성 규칙을 준수하고..

### 클린 아키텍처?

- UI에서 변경의 축?
  - 변경의 축에 의해 정의되는 아키텍처 경계
  - 경계를 가로지르는, 격리하는 API
- 데이터의 흐름을 효과적으로 분리하기
  - 예를 들어 사용자의 통신에 관여하는 흐름, 데이터 영속성에 관여하는 흐름

### 흐름 횡단하기

시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리될 것

### 흐름 분리하기

흐름이 결국 단일 컴포넌트에서 만난다.

더 높은 수준에서 정책 집합이 존재한다.

### 결론

아키텍처 경계는 어디에나 존재하므로, 언제 필요한지 신중하게 파악해야 한다.

경계를 제대로 구현하는데는 비용이 많이 든다.
