# 클린 임베디드 아키텍처

<aside>
💡 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.

펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.

</aside>

- 펌웨어는 ROM, EPROM 혹은 플래시 메모리 같은 비휘발성 메모리에 유지된다.
- 펌웨어는 하드웨어 장치에 프로그래밍된 소프트웨어 프로그램 혹은 명령어 집합이다.
- 펌웨어는 개별 하드웨어에 내장되는 소프트웨어다.
- 펌웨어는 읽기 전용 메모리(ROM)에 쓰여진 소프트웨어(프로그래임이거나 데이터)다.

코드에 SQL을 심거나 개발하는 코드 전반에 플랫폼 의존성을 퍼뜨려 놓은 것 또한 펌웨어를 작성하는 행위

## 앱-티튜드 테스트

- 동작하게 만들어라
- 올바르게 만들어라
  - 리팩터링
- 빠르게 만들어라
  - 성능

많은 임베디드 소프트웨어는 동작하게 만드는 것만을 염두에 두거나, 빠르게 만드는 것에 집착하는데 그러한 애플리케이션이 클린 임베디드 아키텍처를 가진다고 말하기는 어렵다.

## 타깃-하드웨어 병목현상

임베디드가 지닌 특수한 문제 중 하나는 타깃-하드웨어 병목현상이다.

예를 들면 제한된 메모리 공간, 실시간성 제약과 처리완료 시간, 제한된 입출력, 특정한 사용자 인터페이스 등의 특수한 관심사로 인해 임베디드 코드를 테스트할 수 있는 환경이 특정 타깃으로 국한되는 경우다.

- 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다.
  - 계층
    - 하드웨어는 기술의 발전과 무어의 법칙에 따라 변한다.
    - 하드웨어와 나머지 시스템을 먼저 분리한다.
    - 소프트웨어와 펌웨어가 서로 섞이는 일은 안티 패턴. 회귀 테스트가 필요해진다.
  - 하드웨어는 세부사항이다.
    - 소프트웨어와 펌웨어 사이의 경계 정의가 어렵다.
    - 이 경계를 하드웨어 추상화 계층이라고 부른다.(HAL)
    - HAL의 API는 소프트웨어의 필요에 맞게 만들어져야 한다.
    - 추상화 수준을 소프트웨어/제품 관점으로 끌어올린다.
    - 계층은 또 다른 계층을 포함할 수 있는 프랙털(fractal) 패턴에 가깝다.
- HAL 사용자에게 하드웨어 세부사항을 드러내지 말라
  - HAL을 잘 만들면 타깃에 상관없이 테스트할 수 있는 경계층이나 대체 지점을 제공한다.
  - 프로세서는 세부사항이다.
    - 모든 소프트웨어는 반드시 프로세스에 독립적
    - 모든 펌웨어가 그럴 수는 없다.
    - 마이크로 컨트롤러로 펌웨어가 저수준 함수들을 프로세서 추상화 계층(PAL)의 형태로 격리시켜줄 수 있다.
    - PAL 상위에 위치하는 펌웨어는 타깃-하드웨어에 관계없이 테스트할 수 있게 되어 펌웨어 자체도 덜 firm해질 수 있다.
  - 운영체제는 세부사항이다.
    - HAL은 필수적
    - 임베디드 시스템이라면 HAL만으로 충분하다.
    - 코드 수명을 늘리기 위해 운영체제를 세부사항으로 취급하고 운영체제에 의존하는 일을 막아햐 한다.
    - 소프트웨어는 운영체제를 통해 운영 환경이 제공하는 서비스에 접근한다.
    - OS는 소프트웨어를 펌웨어로부터 분리하는 계층. OS를 직접 접근하면 문제가 된다.
    - 클린 임베디드 아키텍처는 운영체제 추상화 계층(OSAL)을 통해 소프트웨어를 운영체제로부터 격리시킨다.
    - OSAL은 OS를 사용하는 데 따른 수많은 중복이 격리되어 있는 장소
    - OSAL은 테스트 지점을 만드는 데 도움이 되며 소프트웨어 계층의 코드를 타깃이나 OS에 관계없이 테스트할 수 있게 해준다.
- 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라
  - HAL 추가, OSAL 추가 외에도 모든 주요 계층 내부에서 관심사를 분리하고 인터페이스를 활용하며 대체 가능성을 높이는 방향으로 프로그래밍해야 한다.
  - 계층형 아키텍처는 인터페이스를 통해 프로그래밍하자는 발상
  - 모듈들이 서로 인터페이스를 통해 상호작용한다면 특정 서비스 제공자를 다른 제공자로 대체할 수 있다.
    - 각각 계층 내부에서 테스트가 가능하다.
    - 각 인터페이스는 타깃과는 별개로 테스트할 수 있는 경계층/대체 지점을 제공한다.
  - 인터페이스를 헤더 파일에서 정의해야 하는데, 헤더 파일에 무엇을 포함시킬 지는 신중하게 정해야 한다.
  - 헤더 파일에는 함수 선언과 그 함수에서 사용하는 상수와 구조체 이름만 포함시켜야 한다.
    - 데이터 구조, 상수, 타입 정의들은 구현체에서만 필요한 것
    - 원치 않는 의존성을 만들면 안된다.
    - 구현 세부사항의 가시성을 제한하고, 구현 세부사항은 변경될 것이라고 가정하라
  - DRY 원칙 : 조건부 컴파일 지시자를 반복하지 말라
    - 조건부 컴파일이 너무 많다면
    - 하드웨어 추상화 계층
      - 하드웨어 유형 : HAL 뒤에 가려진 세부사항
      - HAL이 조건부 컴파일 대신 사용할 수 있는 일련의 인터페이스를 제공
      - 링커 또는 실시간 바인딩을 사용해 소프트웨어를 하드웨어와 연결

## 결론

모든 코드가 펌웨어가 되도록 내버려두면 제품이 오래 살아남을 수 없게 된다.

클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는 데 도움을 준다.
