# 1장. 타입스크립트 알아보기

## 아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기

<aside>
💡 타입스크립트는 자바스크립트의 상위 집합이다. 따라서 모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램이다.

</aside>

타입스크립트는 타입 구문 없이도 오류를 잡을 수 있지만, 타입 구문을 추가하면 더 많은 오류를 찾아낼 수 있다.

타입스크립트의 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다.

## 아이템 2. 타입스크립트 설정 이해하기

### tsconfig.js[on]

- noImplicitAny
  - 변수들이 미리 정의된 타입을 가져야 하는지
- strictNullChecks
  - null과 undefined가 모든 타입에서 허용되는지
- noEmitOnError
  - 오류가 있을때 컴파일 하지 말지

## 아이템 3. 코드 생성과 타입이 관계 없음을 이해하기

### 타입스크립트 컴파일러의 역할

1. 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일
2. 코드의 타입 오류 체크

<aside>
💡 코드 생성은 타입 시스템과 무관하다.
타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.

</aside>

- 타입 오류가 있는 코드도 컴파일이 가능하다.
  - 컴파일은 타입 체크와 독립적
  - 타입스크립트의 오류는 경고와 비슷하다.
- 런타임에는 타입 체크가 불가능하다.
  - 속성 체크 방법
  - Tagged Union(태그드 유니온)
    - 런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 태그 기법
  - 클래스
    - 타입(런타임 접근 불가)와 값(런타임 접근 가능)을 둘 다 사용하는 기법
- 타입 연산은 런타임에 영향을 주지 않는다.
  - 타입스크립트는 타입 체커로서의 역할만 한다.
  - 값을 정제하기 위해서는 자바스크립트 연산을 통한 변환 과정이 필요하다.
- 런타임 타입은 선언된 타입과 다를 수 있다.
  - 타입스크립트에서 런타임 타입과 선언된 타입이 다를 수 있다.
- 타입스크립트 타입으로 함수를 오버로드할 수 없다.
  - 타입과 런타임 동작이 무관하므로 함수 오버로딩이 불가능하다. (중복 처리된다.)
  - 함수 오버로딩 기능을 지원하기는 하지만 타입 수준에서만 동작하며, 구현체는 하나뿐이다.
- 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.
  - 타입스크립트의 정적 타입은 비용이 들지 않는다.
  - 런타임 오버헤드가 없는 대신 타입스크립트 컴파일러는 빌드타임 오버헤드가 있다.
    - 컴파일이 빠르며 증분 빌드 시 더욱 빠르다.
    - 오버헤드가 커지면 빌드 도구에서 타입 체크를 건너뛸 수 있다.(transpile only)
  - 타입스크립트가 컴파일하는 코드는 호환성과 성능 사이의 선택이 필요하다. (컴파일 타깃)
    - 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안하거나
    - 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택해야 한다.

## 아이템 4. 구조적 타이핑에 익숙해지기

<aside>
💡 자바스크립트는 덕 타이핑 기반이다. 
타입스크립트는 이를 모델링하기 위해 구조적 타이핑을 사용한다.
타입스크립트는 매개변수가 요구사항을 만족하면 타입을 신경 쓰지 않는 동작을 그대로 모델링한다.

</aside>

- 타입스크립트의 타입은 확장에 열려있다.
  - 타입에 선언된 속성 외에 임의의 속성을 추가 할 수 있다.
  - 그래서 정확한 타입으로 개체를 순회하는 것이 어렵다.
  - 클래스 타입의 경우
    - 객체 리터럴을 할당해도 문제가 되지 않기도 한다. (생성자에 별다른 연산이 없는 경우)
- 구조적 타이핑은 테스트 작성에 유리하다.
  - 더 구체적인 인터페이스 정의는 실제 환경의 정보를 필요로 하지 않게 해준다.
  - 추상화 ⇒ 로직과 테스트를 구현으로부터 분리
- 라이브러리 간의 의존성을 완벽히 분리한다.

## 아이템 5. any 타입 지양하기

<aside>
💡 타입스크립트의 타입 시스템은 점진적이고 선택적이다.
언제든 타입 체커를 해제할 수 있는 것이 any 타입인데, 그 위험성을 알고 써야 한다.

</aside>

- any 타입에는 타입 안전성이 없다.
  - as any로 타입 단언을 하면 원치 않는 결과가 나올 수 있다.
- any는 함수 시그니처를 무시한다.
- any 타입에는 타입스크립트 언어 서비스가 적용되지 않는다.
  - 자동 완성 기능 X
  - 도움말 기능 X. Rename Symbol이 동작하지 않는다.
- any 타입은 코드 리팩터링 때 버그를 감춘다.
  - 타임 체커를 통과해도 런타임에 오류가 발생할 수 있다.
- any는 타입 설계를 감춘다.
  - 상태 객체의 설계를 감출 수 있어 명료한 코드가 깨지고 타입 설계가 불분명해진다.
- any는 타입시스템의 신뢰도를 떨어뜨린다.
  - 런타임에 타입 오류를 발견하게 되면 타입 체커에 대한 신뢰도가 떨어진다.
  - 수많은 any 타입은 오히려 일을 더 어렵게 만들 수 있다.
  - 타입이 실제 값과 일치하면 타입 스크립트가 타입 정보를 나 대신 기억해줄 것이다.
