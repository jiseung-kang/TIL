# HTTP

- HTTP/0.9: 문서화된 최초의 HTTP 버전
  - GET 메서드 한가지
  - 엄청 간단
  - 헤더나 상태코드 없음. 응답은 무조건 HTML 파일 그 자체
- HTTP/1.0: 기존 HTTP의 기능을 확장한 버전
  - 버전 정보가 명시되었고 각 요청﹒응답 사이에서 전송
  - 요청 메서드가 GET, HEAD, POST 세 가지로 확장
  - 상태 코드가 추가되어 클라이언트 측에서 요청 결과에 따라 동작
  - 요청과 응답에 대한 부가적인 메타데이터를 담는 헤더 필드 추가
  - HTTP 헤더(`Content-Type`)의 도움으로 HTML 이외의 파일도 전송 가능
- HTTP/1.1: 표준화된 HTTP
  - HTTP/1.0 설계에서 불완전하고 미처 고려되지 못한 부분([계층적 프록시](https://yeojin-dev.github.io/blog/dumb-proxy/), 캐싱, 연결 지속 등)이 있어서 보완해야 함
  - HTTP/1.0으로 통신한다고 선언해 놓고 사양을 지키지 않은 서버와 클라이언트가 많다 보니 불편함
  - 연결 상태 유지 : 매번 TCP 핸드셰이크 과정 느림. TCP 자체의 흐름 제어, 혼잡 제어로 네트워크 성능 문제 (Keep-Alive)
  - 파이프라이닝 : 여러 요청을 순차적으로 보내면 순서대로 응답을 제공
  - 청크 전송 인코딩, 캐시제어, 호스트
  - HTTPS 등장
    - 신뢰성, 무결성 추가
    - 인증서
    - SSL, TLS 프로토콜로 암호화
    - RESTful API : HTTP의 메서드를 활용해 CRUD를 구현하고 URI로 자원을 명시하는 등 HTTP 통신의 특성을 활용하는 아키텍처
- HTTP/2
  - 헤더(메타 데이터)의 중복
  - HOLB(Head-of-Line Blocking)
  - 하나의 연결 내 multiplexing이 불가능해 요청이 순차적으로 처리되어야 해서 문제가 생기면 후속 요청이 지연됨
  - 물리적인 TCP 연결을 여러개 두어 병렬 연결을 구현(최대 6개)해 임시 해결
  - 서버 → 클라이언트 데이터 전송 기능 없음
  - 요청별 우선순위 없는 문제
  - 2015년 위 문제들을 해결하기 위해 등장
  - SPDY 프로토콜 기반 동작 : 성능 제한 사항을 해결
  - 헤더와 바디가 바이너리로 인코딩된다. 텍스트 기반의 전송이 아닌 바이너리 프레이밍
  - 응답 다중화를 지원 : TCP 연결을 스트림, 메시지, 프레임으로 세분화했음
    - 스트림 : 요청과 응답이 양방향으로 오가는 논리적 연결 단위. TCP 연결에서 여러 개의 스트림이 동시에 존재할 수 있음
    - 메시지 : 하나의 요청과 응답을 구성하는 단위
    - 프레임 : 메시지를 구성하는 최소 단위. 잘게 쪼개어 전송되므로 수신 측에서 다시 조립해 사용
  - 헤더 필드 압축 지원(HPACK) : 허프만 코딩 기법으로 달라진 부분만 다시 전송 (오버헤드 최소화)
  - 서버 푸시 (요청하지 않은 리소스를 미리 보내기)
  - 정수와 트리 구조로 구현된 스트림 별 우선순위 지정 기능
  - 프로토콜 자체의 흐름 제어 기능
- HTTP/3
  - TCP는 신뢰성을 지향해 데이터 손실이 발생하면 재전송을 수행한다.
  - TCP는 패킷을 정확한 순서로 처리하므로 병목 현상이 발생해 자체적인 HOLB를 해결할 수 없음
  - TCP의 혼잡제어가 불필요한 지연을 발생. 프로토콜의 불필요한 헤더 수정 불가
  - QUIC에서 동작 : UDP 기반에서 TCP 신뢰성을 직접 구현
  - QUIC는 패킷 재전송, 혼잡 제어, 흐름 제어 등을 직접 구현
  - O-RTT : 연결 정보 캐싱 및 재사용
  - IP 기반이 아닌 연결 별 고유 UUID를 이용해 각 연결을 식별

## 참고 자료

[웹 개발자라면 알고 있어야 할 HTTP의 진화 과정 - 재그지그의 개발 블로그](https://wormwlrm.github.io/2022/09/02/Evolution-of-HTTP.html)
