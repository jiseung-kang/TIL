# 원시 값과 객체의 비교

원시 값 : 변경 불가능한 값

객체 : 변경 가능한 값

|      | 원시 값            | 객체               |
| ---- | ------------------ | ------------------ |
| 변경 | 불가능             | 가능               |
| 변수 | 실제 값 저장       | 참조 값 저장       |
| 복사 | 원시 값 복사, 전달 | 참조 값 복사, 전달 |
|      | 값에 의한 전달     | 참조에 의한 전달   |

## 원시 값

### 변경 불가능한 값

읽기 전용의 값. 변경 불가능하다는 것은 값에 대한 진술이다.

변수는 언제든지 재할당을 통해 변수 값을 교체할 수 있다.

상수는 단 한번만 할당이 허용된다.

### 문자열과 불변성

원시 값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다.

숫자 값은 동일하게 8바이트가 필요하지만 문자열은 문자의 개수에 따라 필요한 공간의 크기가 달라진다.

> 유사 배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며 length 프로퍼티를 갖는 객체. 문자열은 원시 값이지만 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환된다.

### 값에 의한 전달

원시 값을 복사해서 전달한다.

이는 다른 메모리 공간에 저장된 별개의 값이다.

서로의 값은 서로 영향을 주지 않는다.

> 엄격하게 표현하면 변수에는 메모리 주소가 전달된다.
> 이는 식별자가 메모리 주소를 기억하고 있기 때문이다.

값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다.

결국 별개의 값이 되어 서로 간섭할 수 없다.

## 객체

객체는 프로퍼티를 동적으로 추가하고 삭제할 수 있다. 값에도 제약이 없으며 원시 값처럼 메모리 공간의 크기를 사전에 정해 둘 수 없다.

프로퍼티 키를 인덱스로 사용

해시 테이블? 더 나은 방식을 사용한다.

동적인 프로퍼티, 메서드 추가가 가능한 비효율적인 방식

⇒ 동적 탐색 대신 히든 클래스 방식을 사용. 프로퍼티에 접근하는 성능 보장

### 변경 가능한 값

참조 값은 생성된 객체가 저장된 메모리 공간 주소 그 자체

메모리를 효율적으로 사용하기 위해 객체는 변경 가능한 값으로 설계되었다.

⇒ 여러 개의 식별자가 하나의 객체를 공유할 수 있다.

### 참조에 의한 전달? 공유에 의한 전달?

객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.

두 개의 식별자가 하나의 객체를 공유하므로 어느 한쪽이 객체를 변경하면 서로 영향을 받는다.
