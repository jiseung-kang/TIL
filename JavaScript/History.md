# 자바스크립트의 역사

## Ajax

Ajax가 XMLHTTPRequest라는 이름으로 등장했다.

이전의 웹페이지는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식

⇒ 변경이 필요없는 부분까지 재전송을 받아 불필요한 데이터 통신이 발생했으며, 깜박이는 현상이 발생했다.

## jQuery

DOM을 더욱 쉽게 제어

크로스 브라우징 이슈 어느정도 해결

## V8 자바스크립트 엔진

데스크톱 애플리케이션과 유사한 UX(User Experience) 제공

웹 서버 로직이 대거 클라이언트로 이동

## Node.js

구글 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경

자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경

- 서버 사이드 애플리케이션 개발에 주로 사용
- 모듈, 파일 시스템, HTTP 등 빌트인 API 제공

### Node.js의 비동기 처리

비동기 I/O를 지원하며 Single-Thread 이벤트 루프 기반으로 동작함으로써 요청 처리 성능이 좋다.

- Multi-Thread
  클라이언트의 요청마다 Thread를 발생시킨다.
  동시 접속자 수가 많은 수록 Thread가 많이 발생하며 메모리 자원도 많이 소모한다.
  때문에 서버 업그레이드, Load-Balancing 등의 분산처리가 필요하다.
  ⇒ 이러한 병렬 처리의 대안이 바로 비동기 처리

> IO Blocking 상황을 Thread로 처리하지 말고 비동기로 처리하자

- 이벤트 루프
  클라이언트의 요청을 비동기로 처리하기 위해 이벤트를 발생시켜 서버 내부에 메시지 형태로 전달한다.
  서버 내부에서 Event Loop가 이 메시지를 처리한다.
  그 동안 제어권은 다음 요청으로 넘어가고, 처리가 완료되면 Callback을 호출하여 처리완료를 호출측에 알려준다.
  Event Loop는 요청을 처리하기 위해 내부적으로 약간의 Thread, Process를 사용한다. (Non-Blocking IO, 내부 처리 목적. 요청 처리가 Thread인 것은 아님 ⇒ Thread 수, 오버헤드가 훨씬 적다.)
  Event Loop는 Single-Thread. 요청 처리는 하나의 Thread

> 작업 자체가 오래 걸린다면 전체 서버 처리에 영향을 줄 수 있다.

데이터 실시간 처리를 위해 I/O가 빈번한 SPA에 적합하다.

CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.

## SPA 프레임워크

변경에 유연하면서 확장하기 쉬운 애플리케이션 아키텍처의 구축을 위한 프레임워크이 필요성 ⇒ CBD 방법론 기반의 SPA 대중화

## 자바스크립트와 ECMAScript

ECMAScript : 자바스크립트의 표준 사양 ECMA-262

자바스크립트 : ECMAScript, 클라이언트 사이드 Web API(DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker)

- requestAnimationFrame()
  브라우저에게 수행하기를 원하는 애니메이션을 알리고,
  다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출하게 한다.
  화면에 새로운 애니메이션을 업데이트할 준비가 될때마다 메소드를 호출하자 ⇒ 최신 브라우저에서 성능, 배터리 수명 향상을 위해 이 호출이 백그라운드 탭 등에서 실행 중단된다.
  - 백그라운드 동작 및 비활성화 시 중지(성능 최적화)
  - 최대 1ms(1/1000s)로 제한되며 1초에 60번 동작
  - 다수의 애니메이션에도 각각 타이머 값을 생성 및 참조하지 않고 내부의 동일한 타이머 참조
- Web Worker
  DOM과 관련되지 않은 자바스크립트의 실행을 Web Workers로 이전해서 별도의 쓰레드에서 실행하게 하면 프레임 누락 현상을 방지할 수 있다.
  대신 DOM에 접근하지 못한다.
